package cs555.tebbe.node;

import cs555.tebbe.transport.ConnectionFactory;
import cs555.tebbe.transport.NodeConnection;
import cs555.tebbe.util.ChunkTracker;
import cs555.tebbe.util.ErasureEncoder;
import cs555.tebbe.util.ErasureRecord;
import cs555.tebbe.util.Util;
import cs555.tebbe.wireformats.*;

import java.io.*;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by ct.
 */
public class ClientNode implements Node {

    private NodeConnection _Controller;
    private byte[] cachedBytes;                                             // bytes stored while performing routing logic
    private HashMap<String, String> checksumFileMap = new HashMap<>();
    private HashMap<String, NodeConnection> chunkNodeLiveConnectionsMap = new HashMap<>();
    private HashMap<String, List<ErasureRecord>> erasureMap = new HashMap<>();

    public ClientNode(String chost, int cport) {
        try {
            _Controller = ConnectionFactory.getInstance().buildConnection(this, new Socket(chost, cport));
        } catch(IOException ioe) {
            System.out.println("IOException thrown contacting ControllerNode:"+ioe.getMessage());
            System.exit(0);
        }
    }

    public ClientNode(int sizeKB) throws IOException {
        cachedBytes = new byte[sizeKB * 1024];
        new Random().nextBytes(cachedBytes);
        System.out.println("File size:" + cachedBytes.length);

        ByteArrayOutputStream os = new ByteArrayOutputStream();
        for(int i=0; i < ChunkTracker.getNumChunksToAllocate(sizeKB); i++) {
            os.write(parseChunkBytes(i));
        }
        System.out.println("valid copy?:" + Arrays.equals(cachedBytes, os.toByteArray()));
    }

    public void run() throws IOException {
        printMenu();
        Scanner keyboard = new Scanner(System.in);
        String input = keyboard.nextLine();
        while(input != null) {
            if(input.contains("1")) {
                System.out.println("File name?");
                String fname = keyboard.nextLine();
                System.out.println("Size in KB?");
                optGenerateAndStoreRandomFile(fname, Integer.parseInt(keyboard.nextLine()));
            } else if(input.contains("2")) {
                System.out.println("File name?");
                String fname = keyboard.nextLine();
                System.out.println("Text?");
                optGenerateAndStoreTextFile(fname, keyboard.nextLine());
            } else if(input.contains("4")) {
                List<String> fileList = new ArrayList<>(checksumFileMap.keySet());
                int i=0;
                for(String file : fileList)
                    System.out.println(i++ + ". " + file);
                String tmp = fileList.get(Integer.parseInt(keyboard.nextLine()));
                System.out.println("Selected file to read: " + tmp);
                optReadFile(tmp);
            } else if(input.contains("5")) {
                List<String> fileList = new ArrayList<>(erasureMap.keySet());
                int i=0;
                for(String file : fileList)
                    System.out.println(i++ + ". " + file);
                String tmp = fileList.get(Integer.parseInt(keyboard.nextLine()));
                System.out.println("Selected file to read: " + tmp);
                optReadFileErasure(tmp);
            } else if(input.contains("3")) {
                System.out.println("File path?");
                String fname = keyboard.nextLine();
                File file = new File(fname);
                //Path path = file.toPath();
                sendStoreFileRequest(file);
            }
            input = keyboard.nextLine();
        }
    }

    private byte[][][] cachedShards;
    private void optReadFileErasure(String filename) throws IOException {
        // buffer space to accumulate shards
        int numChunks = erasureMap.get(filename).get(0).numChunks;
        cachedShards = new byte[numChunks][][];
        for(int i=0; i < numChunks; i++) {
            cachedShards[i] = new byte[ErasureEncoder.TOTAL_SHARDS][];
        }

        for(ErasureRecord record : erasureMap.get(filename)) {
            NodeConnection connection = getChunkNodeConnection(record.host);
            if(connection == null) continue;
            connection.sendEvent(EventFactory.buildRequestErasureFragment(connection, record.filename, record.chunk, record.fragment));
        }
    }

    private void optReadFile(String filename) {
        _Controller.sendEvent(EventFactory.buildRequestReadFile(_Controller, filename));
    }

    private void optGenerateAndStoreTextFile(String fname, String text) throws IOException {
        cachedBytes = text.getBytes();
        sendStoreFileRequest(fname);
    }

    private void optGenerateAndStoreRandomFile(String fname, int sizeKB) throws IOException {
        cachedBytes = new byte[sizeKB * 1024];
        new Random().nextBytes(cachedBytes);
        System.out.println("Generated bytes :" + cachedBytes);
        System.out.println("Generated bytes size:" + cachedBytes.length);
        System.out.println("Generated bytes checksum:" + Util.getCheckSumSHA1(cachedBytes));
        sendStoreFileRequest(fname);
    }

    /*
        sends a request to store cachedBytes
     */
    private void sendStoreFileRequest(String fname) throws IOException {
        String checksum = Util.getCheckSumSHA1(cachedBytes);
        System.out.println("storing " + fname + " : " + checksum);
        checksumFileMap.put(fname, checksum);
        _Controller.sendEvent(EventFactory.buildStoreFileRequestEvent(_Controller, fname, cachedBytes.length));
    }

    private void sendStoreFileRequest(File file) throws IOException {
        FileInputStream fis = new FileInputStream(file);
        cachedBytes = new byte[(int)file.length()];
        fis.read(cachedBytes);
        fis.close();
        sendStoreFileRequest(file.getName());
    }


    private void printMenu() {
        System.out.println("\t ********************");
        System.out.println("1. Generate & store random byte file");
        System.out.println("2. Generate & store text file");
        System.out.println("3. Import & store file");
        System.out.println("4. Read file via chunking");
        System.out.println("5. Read file via erasure codes");
        System.out.println("\t ********************");
    }

    @Override
    public synchronized void onEvent(Event event) {
        switch(event.getType()) {
            case Protocol.CHUNK_ROUTE: // route the cached bytes to
                try {
                    processChunkRoute((ChunkRoute) event);
                } catch (IOException e) {
                    System.out.println("Error forwarding chunk");
                    e.printStackTrace();
                }
                break;
            case Protocol.STORE_CHUNK:
                try {
                    accumulateChunks((StoreChunk) event);
                } catch (IOException e) {
                    System.out.println("error reading file");
                    e.printStackTrace();
                }
                break;
            case Protocol.READ_FILE_RESP:
                processReadFileResponse((ChunkRoute) event);
                break;
            case Protocol.CORRUPT_CHUNK_REQ:
                try {
                    processCorruptChunkDetected((ChunkIdentifier) event);
                } catch (IOException e) {
                    System.out.println("error correcting corrupted chunk");
                    e.printStackTrace();
                }
                break;
            case Protocol.LIVE_NODES:
                try {
                    storeErasureEncoded((StoreChunk) event);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                break;
            case Protocol.STORE_ERASURE:
                try {
                    processErasureCollection((StoreChunk) event);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                break;
        }
    }

    private void processErasureCollection(StoreChunk event) throws IOException {
        if(cachedShards==null) return; // file already decoded
        cachedShards[event.getChunkSequenceID()][event.getErasureFragmentID()] = event.getBytesToStore();
        for(byte[][] chunk : cachedShards) {
            int accumulatedFragments = 0;
            for(byte[] fragment : chunk)
                if(fragment != null)
                    accumulatedFragments++;
            if(accumulatedFragments < ErasureEncoder.DATA_SHARDS)
                return;
        }

        // ready to reassemble file
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dout = new DataOutputStream(new BufferedOutputStream(baos));
        for(byte[][] encodedChunk : cachedShards) {
            dout.write(ErasureEncoder.decodeReedSolomon(encodedChunk));
        }
        dout.flush();
        cachedShards = null;
        System.out.println("decoded erasure file result:"+Util.getCheckSumSHA1(baos.toByteArray()));
    }

    private void processCorruptChunkDetected(ChunkIdentifier event) throws IOException {
        String failedNode = Util.removePort(event.getHeader().getSenderKey());
        ChunkReplicaInformation replicaInformation = cachedReplicaData[event.getSequence()];
        String replica = Util.getOtherReplica(replicaInformation, failedNode);
        System.out.println("Correcting error in file, contacting node: " + replica);
        NodeConnection node = getChunkNodeConnection(replica);
        node.sendEvent(EventFactory.buildRequestChunk(node, event.getFilename(), event.getSequence()));
    }

    private void accumulateChunks(StoreChunk event) throws IOException {
        chunkAccumulatorMap.put(event.getChunkSequenceID(), event.getBytesToStore());
        if(chunkAccumulatorMap.size() == numChunksNeeded) {
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            for(Integer i=0; i < numChunksNeeded; i++) {
                byteStream.write(chunkAccumulatorMap.get(i));
            }
            System.out.println("Read file result: " + event.getFileName() + " : " + Util.getCheckSumSHA1(byteStream.toByteArray()));
        }
    }

    private int numChunksNeeded;
    private Map<Integer, byte[]> chunkAccumulatorMap = new ConcurrentHashMap<>();
    private ChunkReplicaInformation[] cachedReplicaData;
    private void processReadFileResponse(ChunkRoute event) {
        // prepare globals to accept chunks
        numChunksNeeded = event.getChunksInformation().length;
        chunkAccumulatorMap.clear();
        cachedReplicaData = event.getChunksInformation();

        System.out.println("reading file...:" + event.getFileName());
        int chunk=0;
        for(ChunkReplicaInformation info : event.getChunksInformation()) {
            try {
                getChunkNodeConnection(info.getReplicaChunkNodes()[0]).sendEvent(
                        EventFactory.buildRequestChunk(getChunkNodeConnection(info.getReplicaChunkNodes()[0]), event.getFileName(), chunk++));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private final List<byte[]> cachedChunks = new ArrayList<>();
    private void processChunkRoute(ChunkRoute event) throws IOException {
        cachedChunks.clear();
        int chunkSequence = 0;
        for(ChunkReplicaInformation info : event.getChunksInformation()) { // process each chunk, send to first replica
            byte[] chunk = parseChunkBytes(chunkSequence);
            getChunkNodeConnection(info.getReplicaChunkNodes()[0]).sendEvent(
                    EventFactory.buildStoreChunkEvent(getChunkNodeConnection(info.getReplicaChunkNodes()[0]), event.getFileName(), "0.1", chunkSequence, chunk, info));
            cachedChunks.add(chunk);
            chunkSequence++;
        }
        _Controller.sendEvent(EventFactory.buildStoreErasureFragmentRequest(_Controller, event.getFileName()));
    }

    private void storeErasureEncoded(StoreChunk event) throws IOException {
        Random random = new Random();
        String[] nodes = event.getChunkReplicaInformation().getReplicaChunkNodes();

        // encode
        byte[][][] encodedChunks = new byte[cachedChunks.size()][][];
        for(int i=0; i < cachedChunks.size(); i++) {
            encodedChunks[i] = ErasureEncoder.encodeReedSolomon(cachedChunks.get(i));
        }

        // distribute chunk shards
        erasureMap.put(event.getFileName(), new ArrayList<ErasureRecord>());
        List recordList = erasureMap.get(event.getFileName());
        for(int chunk=0; chunk < encodedChunks.length; chunk++) {           // chunks
            for(int fragment=0; fragment < encodedChunks[chunk].length; fragment++) {    // shards
                NodeConnection connection = getChunkNodeConnection(Util.removePort(nodes[random.nextInt(nodes.length)]));
                //System.out.println("sending chunk " + chunk + " fragment " + fragment + " to " + connection.getRemoteKey());
                recordList.add(new ErasureRecord(Util.removePort(connection.getRemoteKey()), event.getFileName(), chunk, fragment, encodedChunks.length));
                connection.sendEvent(EventFactory.buildStoreErasureFragment(connection, event.getFileName(), chunk, encodedChunks[chunk][fragment], fragment));
            }
        }
    }

    private NodeConnection getChunkNodeConnection(String hostname) throws IOException {
        synchronized (chunkNodeLiveConnectionsMap) {
            if(!chunkNodeLiveConnectionsMap.containsKey(hostname))
                chunkNodeLiveConnectionsMap.put(hostname, ConnectionFactory.buildConnection(this, hostname, ChunkNode.DEFAULT_SERVER_PORT));
            return chunkNodeLiveConnectionsMap.get(hostname);
        }
    }

    /*
        pull a desired chunk from cachedBytes
     */
    private byte[] parseChunkBytes(int chunkNumber) {
        int idealChunkSize = (int) Protocol.CHUNK_SIZE_KB * 1024;
        int startIndex = idealChunkSize*chunkNumber+chunkNumber;
        int endIndex =  (startIndex+idealChunkSize > cachedBytes.length-1) ? cachedBytes.length-1 : startIndex+idealChunkSize;
        int chunkSize = endIndex - startIndex + 1;

        byte[] chunkBytes = new byte[chunkSize];
        System.arraycopy(cachedBytes, startIndex, chunkBytes, 0, chunkSize);
        return chunkBytes;
    }

    @Override
    public void registerConnection(NodeConnection connection) {

    }

    @Override
    public void lostConnection(String disconnectedIP) {
        chunkNodeLiveConnectionsMap.remove(disconnectedIP);
    }

    public static void main(String[] args) {
        if(args.length > 0) {
            String host = args[0];
            int port = Integer.parseInt(args[1]);
            try {
                new ClientNode(host,port).run();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("Usage: java ClientNode controller_host controller_port");
        }
    }
}
