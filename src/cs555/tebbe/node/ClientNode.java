package cs555.tebbe.node;

import cs555.tebbe.transport.ConnectionFactory;
import cs555.tebbe.transport.NodeConnection;
import cs555.tebbe.util.ChunkTracker;
import cs555.tebbe.util.Util;
import cs555.tebbe.wireformats.*;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by ct.
 */
public class ClientNode implements Node {

    private NodeConnection _Controller;
    private byte[] cachedBytes;                                             // bytes stored while performing routing logic
    private HashMap<String, String> checksumFileMap = new HashMap<>();
    private HashMap<String, NodeConnection> chunkNodeLiveConnectionsMap = new HashMap<>();

    public ClientNode(String chost, int cport) {
        try {
            _Controller = ConnectionFactory.getInstance().buildConnection(this, new Socket(chost, cport));
        } catch(IOException ioe) {
            System.out.println("IOException thrown contacting ControllerNode:"+ioe.getMessage());
            System.exit(0);
        }
    }

    public ClientNode(int sizeKB) throws IOException {
        cachedBytes = new byte[sizeKB * 1024];
        new Random().nextBytes(cachedBytes);
        System.out.println("File size:" + cachedBytes.length);

        ByteArrayOutputStream os = new ByteArrayOutputStream();
        for(int i=0; i < ChunkTracker.getNumChunksToAllocate(sizeKB); i++) {
            os.write(parseChunkBytes(i));
        }
        System.out.println("valid copy?:" + Arrays.equals(cachedBytes, os.toByteArray()));
    }

    public void run() throws IOException {
        printMenu();
        Scanner keyboard = new Scanner(System.in);
        String input = keyboard.nextLine();
        while(input != null) {
            if(input.contains("1")) {
                System.out.println("File name?");
                String fname = keyboard.nextLine();
                System.out.println("Size in KB?");
                optGenerateAndStoreRandomFile(fname, Integer.parseInt(keyboard.nextLine()));
            } else if(input.contains("2")) {
                System.out.println("File name?");
                String fname = keyboard.nextLine();
                System.out.println("Text?");
                optGenerateAndStoreTextFile(fname, keyboard.nextLine());
            } else if(input.contains("3")) {
                List<String> fileList = new ArrayList<>(checksumFileMap.keySet());
                int i=0;
                for(String file : fileList)
                    System.out.println(i++ + ". " + file);
                String tmp = fileList.get(Integer.parseInt(keyboard.nextLine()));
                System.out.println("Selected file to read: " + tmp);
                optReadFile(tmp);
            }
            input = keyboard.nextLine();
        }
    }

    private void optReadFile(String filename) {
        _Controller.sendEvent(EventFactory.buildRequestReadFile(_Controller, filename));
    }

    private void optGenerateAndStoreTextFile(String fname, String text) throws IOException {
        cachedBytes = text.getBytes();
        sendStoreFileRequest(fname);
    }

    private void optGenerateAndStoreRandomFile(String fname, int sizeKB) throws IOException {
        cachedBytes = new byte[sizeKB * 1024];
        new Random().nextBytes(cachedBytes);
        System.out.println("Generated bytes :" + cachedBytes);
        System.out.println("Generated bytes size:" + cachedBytes.length);
        System.out.println("Generated bytes checksum:" + Util.getCheckSumSHA1(cachedBytes));
        sendStoreFileRequest(fname);
    }

    /*
        sends a request to store cachedBytes
     */
    private void sendStoreFileRequest(String fname) throws IOException {
        String checksum = Util.getCheckSumSHA1(cachedBytes);
        System.out.println("storing " + fname + " : " + checksum);
        checksumFileMap.put(fname, checksum);
        _Controller.sendEvent(EventFactory.buildStoreFileRequestEvent(_Controller, fname, cachedBytes.length));
    }

    private void printMenu() {
        System.out.println("\t ********************");
        System.out.println("1. Generate & store random byte file");
        System.out.println("2. Generate & store text file");
        System.out.println("3. Read file");
        System.out.println("\t ********************");
    }

    @Override
    public synchronized void onEvent(Event event) {
        switch(event.getType()) {
            case Protocol.CHUNK_ROUTE: // route the cached bytes to
                try {
                    processChunkRoute((ChunkRoute) event);
                } catch (IOException e) {
                    System.out.println("Error forwarding chunk");
                    e.printStackTrace();
                }
                break;
            case Protocol.STORE_CHUNK:
                try {
                    accumulateChunks((StoreChunk) event);
                } catch (IOException e) {
                    System.out.println("error reading file");
                    e.printStackTrace();
                }
                break;
            case Protocol.READ_FILE_RESP:
                processReadFileResponse((ChunkRoute) event);
                break;
            case Protocol.CORRUPT_CHUNK_REQ:
                try {
                    processCorruptChunkDetected((ChunkIdentifier) event);
                } catch (IOException e) {
                    System.out.println("error correcting corrupted chunk");
                    e.printStackTrace();
                }
        }
    }

    private void processCorruptChunkDetected(ChunkIdentifier event) throws IOException {
        String failedNode = Util.removePort(event.getHeader().getSenderKey());
        ChunkReplicaInformation replicaInformation = cachedReplicaData[event.getSequence()];
        String replica = Util.getOtherReplica(replicaInformation, failedNode);
        System.out.println("Correcting error in file, contacting node: " + replica);
        NodeConnection node = getChunkNodeConnection(replica);
        node.sendEvent(EventFactory.buildRequestChunk(node, event.getFilename(), event.getSequence()));
    }

    private void accumulateChunks(StoreChunk event) throws IOException {
        chunkAccumulatorMap.put(event.getChunkSequenceID(), event.getBytesToStore());
        if(chunkAccumulatorMap.size() == numChunksNeeded) {
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            for(Integer i=0; i < numChunksNeeded; i++) {
                byteStream.write(chunkAccumulatorMap.get(i));
            }
            System.out.println("Read file result: " + event.getFileName() + " : " + Util.getCheckSumSHA1(byteStream.toByteArray()));
        }
    }

    private int numChunksNeeded;
    private Map<Integer, byte[]> chunkAccumulatorMap = new ConcurrentHashMap<>();
    private ChunkReplicaInformation[] cachedReplicaData;
    private void processReadFileResponse(ChunkRoute event) {
        // prepare globals to accept chunks
        numChunksNeeded = event.getChunksInformation().length;
        chunkAccumulatorMap.clear();
        cachedReplicaData = event.getChunksInformation();

        System.out.println("reading file...:" + event.getFileName());
        int chunk=0;
        for(ChunkReplicaInformation info : event.getChunksInformation()) {
            try {
                getChunkNodeConnection(info.getReplicaChunkNodes()[0]).sendEvent(
                        EventFactory.buildRequestChunk(getChunkNodeConnection(info.getReplicaChunkNodes()[0]), event.getFileName(), chunk++));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private void processChunkRoute(ChunkRoute event) throws IOException {
        int chunkSequence = 0;
        for(ChunkReplicaInformation info : event.getChunksInformation()) { // process each chunk, send to first replica
            getChunkNodeConnection(info.getReplicaChunkNodes()[0]).sendEvent(
                    EventFactory.buildStoreChunkEvent(getChunkNodeConnection(info.getReplicaChunkNodes()[0]), event.getFileName(), "0.1", chunkSequence, parseChunkBytes(chunkSequence++), info));
        }
    }

    private NodeConnection getChunkNodeConnection(String hostname) throws IOException {
        synchronized (chunkNodeLiveConnectionsMap) {
            if(!chunkNodeLiveConnectionsMap.containsKey(hostname))
                chunkNodeLiveConnectionsMap.put(hostname, ConnectionFactory.buildConnection(this, hostname, ChunkNode.DEFAULT_SERVER_PORT));
            return chunkNodeLiveConnectionsMap.get(hostname);
        }
    }

    /*
        pull a desired chunk from cachedBytes
     */
    private byte[] parseChunkBytes(int chunkNumber) {
        int idealChunkSize = (int) Protocol.CHUNK_SIZE_KB * 1024;
        int startIndex = idealChunkSize*chunkNumber+chunkNumber;
        int endIndex =  (startIndex+idealChunkSize > cachedBytes.length-1) ? cachedBytes.length-1 : startIndex+idealChunkSize;
        int chunkSize = endIndex - startIndex + 1;

        byte[] chunkBytes = new byte[chunkSize];
        System.arraycopy(cachedBytes, startIndex, chunkBytes, 0, chunkSize);
        return chunkBytes;
    }

    @Override
    public void registerConnection(NodeConnection connection) {

    }

    @Override
    public void lostConnection(String disconnectedIP) {
        chunkNodeLiveConnectionsMap.remove(disconnectedIP);
    }

    public static void main(String[] args) {
        if(args.length > 0) {
            String host = args[0];
            int port = Integer.parseInt(args[1]);
            try {
                new ClientNode(host,port).run();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("Usage: java ClientNode controller_host controller_port");
        }
    }
}
