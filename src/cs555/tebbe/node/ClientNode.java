package cs555.tebbe.node;

import cs555.tebbe.transport.ConnectionFactory;
import cs555.tebbe.transport.NodeConnection;
import cs555.tebbe.wireformats.*;

import java.io.IOException;
import java.net.Socket;
import java.util.*;

/**
 * Created by ct.
 */
public class ClientNode implements Node {

    private NodeConnection _Controller;
    private byte[] cachedBytes;

    public ClientNode(String chost, int cport) {
        try {
            _Controller = ConnectionFactory.getInstance().buildConnection(this, new Socket(chost, cport));
        } catch(IOException ioe) {
            System.out.println("IOException thrown contacting ControllerNode:"+ioe.getMessage());
            System.exit(0);
        }
    }

    public void run() throws IOException {
        printMenu();
        Scanner keyboard = new Scanner(System.in);
        String input = keyboard.nextLine();
        while(input != null) {
            if(input.contains("1")) {
                System.out.println("File name?");
                String fname = keyboard.nextLine();
                System.out.println("Size in KB?");
                optGenerateAndStoreRandomFile(fname, Integer.parseInt(keyboard.nextLine()));
            }
            input = keyboard.nextLine();
        }
    }

    private void optGenerateAndStoreRandomFile(String fname, int sizeKB) throws IOException {
        cachedBytes = new byte[sizeKB * 1024];
        new Random().nextBytes(cachedBytes);
        System.out.println("Generated bytes:" + cachedBytes);
        _Controller.sendEvent(EventFactory.buildStoreFileRequestEvent(_Controller, fname, cachedBytes.length));
    }

    private void printMenu() {
        System.out.println("\t ********************");
        System.out.println("1. Generate & store random file");
        System.out.println("\t ********************");
    }

    @Override
    public void onEvent(Event event) {
        switch(event.getType()) {
            case Protocol.CHUNK_ROUTE: // route the cached bytes to
                try {
                    processChunkRoute((ChunkRoute) event);
                } catch (IOException e) {
                    System.out.println("Error forwarding chunk");
                    e.printStackTrace();
                }
                break;
            case Protocol.STORE_CHUNK:
                StoreChunk sc = (StoreChunk) event;
                System.out.println("**** back File name:" + sc.getFileName());
                System.out.println("**** back bytes size:" + sc.getBytesToStore().length);
                System.out.println("**** backBytes:");
                try {
                    System.out.write(((StoreChunk) event).getBytesToStore());
                } catch (IOException e) {
                    e.printStackTrace();
                }
                System.out.println();
        }
    }

    private void processChunkRoute(ChunkRoute event) throws IOException {
        System.out.println("* Received new chunk route");
        System.out.println(event.getFileName());

        System.out.println("File to split:" + cachedBytes);
        int chunkSequence = 1;
        ChunkReplicaInformation info = event.getChunksInformation()[0];
        NodeConnection tmpConn = ConnectionFactory.buildConnection(this, info.getReplicaChunkNodes()[0], ChunkNode.DEFAULT_SERVER_PORT);
        System.out.println(tmpConn.getRemoteKey());
        byte[] parsed = parseChunkBytes(chunkSequence++);
        tmpConn.sendEvent(EventFactory.buildStoreChunkEvent(tmpConn, event.getFileName(), chunkSequence, parsed, info));
        System.out.println("Bytes sent length: " + parsed.length);
        System.out.println("Bytes sent: ");
        System.out.write(parsed);
        System.out.println();
        /*
        for(ChunkReplicaInformation info : event.getChunksInformation()) { // process each chunk, send to first replica
            NodeConnection tmpConn = ConnectionFactory.buildConnection(this, info.getReplicaChunkNodes()[0], ChunkNode.DEFAULT_SERVER_PORT);
            System.out.println(tmpConn.getRemoteKey());
            tmpConn.sendEvent(EventFactory.buildStoreChunkEvent(tmpConn, event.getFileName(), chunkSequence, parseChunkBytes(chunkSequence++), info));
            System.out.println("Bytes sent length: " + parseChunkBytes(chunkSequence - 1).length);
            System.out.println("Bytes sent: " + parseChunkBytes(chunkSequence-1));
        }
        */
    }

    /*
        pull a desired chunk from cachedBytes
     */
    private byte[] parseChunkBytes(int chunkNumber) {
        int chunkSize = (int) Protocol.CHUNK_SIZE_KB;
        System.out.println("start index:" + String.valueOf(chunkNumber==1 ? 0 : (chunkSize*(chunkNumber-1))-1));
        System.out.println("end index:" + (chunkSize*chunkNumber > cachedBytes.length ? cachedBytes.length-1 : (chunkSize*chunkNumber)-1));
        return Arrays.copyOfRange(cachedBytes,
                chunkNumber==1 ? 0 : (chunkSize*(chunkNumber-1))-1,                                                 // start index
                chunkSize*chunkNumber > cachedBytes.length ? cachedBytes.length-1 : (chunkSize*chunkNumber)-1);     // end index, dont exceed array bounds
    }

    @Override
    public void registerConnection(NodeConnection connection) {

    }

    public static void main(String[] args) {
        if(args.length > 0) {
            String host = args[0];
            int port = Integer.parseInt(args[1]);
            try {
                new ClientNode(host,port).run();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("Usage: java ClientNode controller_host controller_port");
        }
    }
}
